<!-- TOC -->

- [1. 问题](#1-%E9%97%AE%E9%A2%98)
- [2. 思路](#2-%E6%80%9D%E8%B7%AF)
- [3. 解决方案](#3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
    - [3.1. 程序员进阶](#31-%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6)
        - [3.1.1. 普通程序到进阶程序](#311-%E6%99%AE%E9%80%9A%E7%A8%8B%E5%BA%8F%E5%88%B0%E8%BF%9B%E9%98%B6%E7%A8%8B%E5%BA%8F)
        - [3.1.2. 从进阶程序到顶级程序](#312-%E4%BB%8E%E8%BF%9B%E9%98%B6%E7%A8%8B%E5%BA%8F%E5%88%B0%E9%A1%B6%E7%BA%A7%E7%A8%8B%E5%BA%8F)
    - [3.2. 题目的探索](#32-%E9%A2%98%E7%9B%AE%E7%9A%84%E6%8E%A2%E7%B4%A2)
    - [3.3. 存储结构](#33-%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84)
    - [3.4. 数据结构](#34-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
        - [3.4.1. 队列](#341-%E9%98%9F%E5%88%97)
        - [3.4.2. 栈](#342-%E6%A0%88)
        - [3.4.3. hashmap](#343-hashmap)
        - [3.4.4. 二叉树](#344-%E4%BA%8C%E5%8F%89%E6%A0%91)
        - [3.4.5. 图](#345-%E5%9B%BE)
    - [3.5. 算法--方法](#35-%E7%AE%97%E6%B3%95--%E6%96%B9%E6%B3%95)
        - [3.5.1. 暴力法](#351-%E6%9A%B4%E5%8A%9B%E6%B3%95)
        - [3.5.2. 分治法](#352-%E5%88%86%E6%B2%BB%E6%B3%95)
        - [3.5.3. 其它](#353-%E5%85%B6%E5%AE%83)
    - [3.6. 算法--问题](#36-%E7%AE%97%E6%B3%95--%E9%97%AE%E9%A2%98)
        - [3.6.1. 查找](#361-%E6%9F%A5%E6%89%BE)
        - [3.6.2. 排序](#362-%E6%8E%92%E5%BA%8F)
            - [3.6.2.1. 插入排序](#3621-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)
            - [3.6.2.2. 交换排序](#3622-%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F)
            - [3.6.2.3. 选择排序](#3623-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)
            - [3.6.2.4. 归并排序](#3624-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)
            - [3.6.2.5. 其它排序](#3625-%E5%85%B6%E5%AE%83%E6%8E%92%E5%BA%8F)
    - [3.7. 面对问题的通用思路](#37-%E9%9D%A2%E5%AF%B9%E9%97%AE%E9%A2%98%E7%9A%84%E9%80%9A%E7%94%A8%E6%80%9D%E8%B7%AF)
- [4. 结论](#4-%E7%BB%93%E8%AE%BA)
- [5. 展望](#5-%E5%B1%95%E6%9C%9B)
- [6. 问题](#6-%E9%97%AE%E9%A2%98)
- [7. 文献](#7-%E6%96%87%E7%8C%AE)

<!-- /TOC -->



--------------------------------------------------------------------------

# 1. 问题
团队人员最基本的能力，就是算法和数据结构，怎样的培训，可以提升算法能力？




--------------------------------------------------------------------------

# 2. 思路

* 掌握算法算法有三个层次：

  * 普通程序，他们会用相对暴力的方式解决问题。

  * 进阶程序，他们通过自己不断的学习，掌握了一定的算法，因此，会用一定的算法解决部分问题。

  * 顶级程序(acmer)，他们经过系统的培训，掌握了许多的算法，因此，面对问题，可以解决更多的问题。

* 面对问题的通用思路




--------------------------------------------------------------------------

# 3. 解决方案

## 3.1. 程序员进阶

### 3.1.1. 普通程序到进阶程序

* 认识算法的重要性

* 保持积极的学习和积累

* 利用已有的算法解决工作中的问题


### 3.1.2. 从进阶程序到顶级程序

* 需要有系统的学习

* 需要刻意的训练

* 需要总结

* 算法应用，解决复杂问题

## 3.2. 题目的探索

聪明的人类解决问题，也会不断的探索不同的解法：

* 暴力穷举法。最直接，最简单的方法，尝试所有情况，找到符合条件的解。包括深度遍历，广度遍历，回溯都是这个思路。

* 直接解决问题，拆解子问题：递归、分治、动态规划等通用的解决办法

* 特殊的办法，比如最长回文字符子串的马拉车算法

> 对于顶级程序，能够实现前两种方法，第三种需要见识，看多了，知道有解决的办法，到时去找即可

## 3.3. 存储结构
* 数组

* 链表
  * 单链表
  * 双向链表

## 3.4. 数据结构

### 3.4.1. 队列
  * 定义：先进后出
  * 存储结构
    * 顺序存储
    * 链式存储
    * 
  * 算法
    * 循环队列
    * 双向队列
    * 单调队列


### 3.4.2. 栈
  * 定义：先进后出
  * 存储结构
    * 顺序存储
    * 链式存储
  * 算法
    * 单调栈

### 3.4.3. hashmap
  * 散列函数
    * 直接定址法
    * 数字分析法
    * 平方取中法
    * 折叠法
    * 除留余数法
    * 随机数法
  * 冲突处理
    * 开放地址法
    * 再散列函数法
    * 链地址法
    * 公共溢出区法

### 3.4.4. 二叉树
  * 树和二叉树相互转换 
  * 语法定义
  * 语法和存储结构
      * 顺序存储
      * 链式存储
  * 遍历算法
    * 广度遍历
      * 迭代遍历（利用队列） 
    * 深度遍历
      * 前序遍历
        * 递归
        * 迭代
      * 中序遍历
        * 递归
        * 迭代
        * morris算法
      * 后续遍历
        * 递归
        * 迭代
    * hoffman树
        * 带权值节树

### 3.4.5. 图
  * 存储结构
    * 邻接矩阵
    * 邻接表
    * 十字链表
    * 邻接多重表
    * 边集数组
  * 算法
    * 深度优先遍历
    * 广度优先遍历
    * 最小生成树
    * 最短路径
    * 拓扑排序
    * 关键路径

## 3.5. 算法--方法

### 3.5.1. 暴力法
* 暴力穷举法
* 深度广度遍历法
* 回朔法

### 3.5.2. 分治法
* 分解子问题相同：递归（递归优化，存储重复结果）
* 分解子问题重复解：动态规划法

### 3.5.3. 其它
* 贪心法
* 双指针
* 马拉车
* 。。。

## 3.6. 算法--问题

### 3.6.1. 查找
* 顺序查找
* 有序表查找
  * 二分查找
  * 斐波那契查找
  * 插值查找
* 索引查找
* 二叉排序树查找（平衡二叉树、红黑树）
* <font color=red>2-3树，2-3-4树，B树，B+树</font>
* hash查找

### 3.6.2. 排序

#### 3.6.2.1. 插入排序
* 简单插入排序
* 希尔排序

#### 3.6.2.2. 交换排序
* 冒泡排序
* 快速排序

#### 3.6.2.3. 选择排序
* 选择排序
* 堆排序

#### 3.6.2.4. 归并排序
* 归并排序

#### 3.6.2.5. 其它排序
* 桶排序
* 基数排序
* 计数排序

## 3.7. 面对问题的通用思路
* 分治法
* 递归--迭代
* 动态规划

* 回朔法
* 贪心法
* 双指针


# 4. 结论



# 5. 展望
对应算法，以前我一直有一些误解，认为在解决一个问题的时候，尝试用现有的知识，一个个的去遍历，去尝试，是一种非常愚蠢的方法。

现在，我有新的想法。

当我们面对一个问题的时候，我们可以通过问题的一些特征，去匹配问题的解决方案，这是类似hash的算法，是最快的，我们知道hash是o(1)的复杂度。

当我们没办法提取特征，或没办法用这些特征，去匹配问题的解决方案的时候，利用遍历，是一个简单有效的方法，我们把它理解为探索，把它理解为摸索，这是人类探索未知问题，最为常用的办法，也必将是我未来解决算法问题的保底策略，尽管笨，但他可以解决的问题集合是比动态、比贪心等任何一种方法，都更大。

希望，我能在学习新的算法的同时，不要忘了自己的保底策略--遍历尝试。

# 6. 问题

* 为啥快排是排序算法中的王者？
  为什么各种排序算法都有快速排序的实现，论稳定性，不如归并；论空间复杂度，不如堆排；论时间复杂度，也不如堆排，不太懂为什么不选择堆排作为算法的实现？
  主要解释：
  * 适合cache读取：快排的数据是连续的[5]
  * 堆排：每次调整堆，都出现大量无效的比较[6]
  * 时间复杂度是：c*n*logn，c作为常数，在实际应用过程中，对数据计算也是会比较有影响的[7]
  * 信息论统计结果表明[6]

* 

# 7. 文献
* [1] https://www.zhihu.com/question/68073393/answer/260642677
* [2] [算法分类目录](https://blog.csdn.net/sun897949163/article/details/49559679)
* [3] [labuladong](公众号)
* [4] https://blog.csdn.net/xielingxuan666/article/details/83510841
* [5] [为什么在平均情况下快速排序比堆排序要优秀？](https://www.zhihu.com/question/23873747)
* [6] [数学之美番外篇：快排为什么那样快](http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/)
* [7] [为什么说快速排序是最快排序算法？](https://youyou-tech.com/2019/10/26/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%98%AF%E6%9C%80%E5%BF%AB%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%9F/)

